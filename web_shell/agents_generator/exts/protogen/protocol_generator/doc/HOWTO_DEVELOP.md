Protocol Generator developper documentation
===========================================

(note: not really up-to-date)

# Generated code organisation

In order to ease the change of generated code features (especialy in the transition from msgpack to protobuf), the generated code is seperated in distinct blocks, which APIs are (as often as possible) not related to the technological solution chosen. For example, no redis reference in the CookieManager's APIs, no msgapck or protobuf reference in the Codec's APIs, etc.)

Here is the interractions between all the blocks:

[Server code blocks](CodeBlocksServer.png)


[Device code blocks](CodeBlocksDevice.png)

# Plugin system

We also tried to mark this independance in the protocol generator's code. Each block will be generated by a "plugin".

If you want to create your own plugin to replace one of the blocks, (make sure it complies with the previously defined APIs), you'll have to put it in the lib/plugins/ directory, and add it in the plugin list in the input configuration file. The plugin must have an init.rb file in the same format than the existing one (the plugin must inherit from GeneratorPlugin, you must call init (defined in GeneratorPlugin) at the end of the definition of your plugin.

Though, we tried to keep the independance as much as we could, there is still a dependance between the codec and message plugins (protobuf codec obviously won't work with msgpack message). This is dealt with a dependancy relation between plugins. See ruby_codec_msgpack plugin for example. Should a plugin B, dependant on A, be called, A would be called first, even if it is not present in the configuration file.

Also a priority for a plugin is defined. Indeed, one plugin might need to be called before another one (to fill a environment variable used in the next). See ruby_messages_protobuf example. It is an integer (or a float, whatever can rightfuly be compared to an int ^^). Default priority is 0. Note that a dependancy plugin will be called before the dependant plugin, whatever its priority.


# Accessing variables through the project

Every piece of information is stored in Env "alias" for ProtocolGenerator::Environment.env, which is sort of a global hash. It is still kind of a mess, inside, but you will certainly find what you want.



# How messages are formated

Each message, once serialized, share the same structure :


    { /* messagewrap */
      "type":1, /* int, id of the message. */
      "msg":{
        "surname":"John",
        "name":"Malkovich",
        "age":59,
        "_protogen_sequence_id":1,
        "_protogen_shot_id":2
        …
      },
      "_cookieA":{
        "expiration":123456789, /* int, timestamp of the expiration date of the cookie */
        "content":"3NcRYP73D57UfF" /* encrypted content */
        "sig":"516n47uR3" /* signature */
      },
      "_cookieB":{
        …
      }

      …
    }