package <%= Env['java_package']%>;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.msgpack.MessagePack;
import org.msgpack.template.Template;
import org.msgpack.unpacker.Unpacker;
import org.msgpack.type.ArrayValue;
import org.msgpack.type.Value;
import static org.msgpack.template.Templates.TString;
import static org.msgpack.template.Templates.TValue;
import static org.msgpack.template.Templates.tMap;

import com.mdi.tools.std.BuffRef;

<% if Env['use_cookies'] %>import <%= Env['java_package']%>.CookieJar.StoredCookie;<% end %>
import <%= Env['java_package']%>.MDIMessages;

public class Codec {

  public static final String PROTOCOL_VERSION = <%= Env['protocol_version'] %>;
  public static final String PG_VERSION = "<%= ::ProtocolGenerator.version %>";

  public static class UnknownMessage extends Exception {
    public UnknownMessage(String message) {
      super(message);
    }
  }

  public static class PartialMessage extends Exception {
    public PartialMessage(String message) {
      super(message);
    }
  }

  public static class CorruptedMessage extends Exception {
    public CorruptedMessage(String message) {
      super(message);
    }
  }

  public static class Splitter {

    private static Map<String, Map<Integer, byte[]>> _messageParts = new HashMap<String, Map<Integer, byte[]>>();

    public static Map<Integer, byte[]> getStoredParts(String messageHash) {
      Map<Integer, byte[]> sp = _messageParts.get(messageHash);
      if (sp == null) {
        return new HashMap<Integer, byte[]>();
      } else {
        return sp;
      }
    }

    public static void put(byte[] partContent, String messageHash, int messageFraction) {
      Map<Integer, byte[]> parts = getStoredParts(messageHash);
      parts.put(messageFraction, partContent);
      _messageParts.put(messageHash, parts);
    }


    public static BuffRef assemble(Map<Integer, byte[]> otherMessageParts, String messageHash) throws CorruptedMessage {
      _messageParts.remove(messageHash);

      ByteArrayOutputStream completeMessage = new ByteArrayOutputStream();
      for (int i = 0; i < otherMessageParts.size(); i++) {
        try {
          completeMessage.write(otherMessageParts.get(i));
        } catch (IOException e) {
          throw new CorruptedMessage("IOException on message part " + i);
        }
      }

      // todo check hash

      return new BuffRef(completeMessage.toByteArray());
    }
  }
<% if Env['use_cookies'] %>
  public static CookieJar.StoredCookie toStoredCookie(Value value) {
    ArrayValue tab = value.asArrayValue();
    BuffRef content = new BuffRef(tab.get(0).asRawValue().getByteArray());
    BuffRef signature = new BuffRef(tab.get(1).asRawValue().getString());
    int expiration = tab.get(2).asIntegerValue().getInt();
    return new CookieJar.StoredCookie(content, signature, expiration);
  }

  public static List<Object> toList(StoredCookie sc) {
    List<Object> list = new ArrayList<Object>();
    list.add(sc.content.getBytes());
    list.add(sc.signature.toString());
    list.add(sc.expiration);
    return list;
  }<% end %>



  public static MDIMessages.<%= Env['java_message_parent_class']%> decode(BuffRef message)
      throws CorruptedMessage, UnknownMessage, PartialMessage {

    final MessagePack msgpack = new MessagePack();
    final ByteArrayInputStream in = new ByteArrayInputStream(message.getBytes());
    final Unpacker unpacker = msgpack.createUnpacker(in);

    final Template<Map<String, Value>> requestTmpl = tMap(TString, TValue);
    Map<String, Value> wrap;
    try {
      wrap = unpacker.read(requestTmpl);
    } catch (IOException e) {
      e.printStackTrace();
      return null;
    }

    // "h" presence means this is a partial message
    if (wrap.containsKey("h")) {
      String messageHash = wrap.get("h").asRawValue().getString();
      int messageFraction = wrap.get("f").asIntegerValue().getInt();
      int totalParts = wrap.get("t").asIntegerValue().getInt();
      byte[] partContent = wrap.get("m").asRawValue().getByteArray();

      Map<Integer, byte[]> otherMessageParts = Splitter.getStoredParts(messageHash);
      if (otherMessageParts.size() + 1 == totalParts) {
        otherMessageParts.put(messageFraction, partContent);
        return decode(Splitter.assemble(otherMessageParts, messageHash));
      } else {
        Splitter.put(partContent, messageHash, messageFraction);
        throw new PartialMessage("Received part " + messageFraction + "/" + totalParts + " of message " + messageHash);
      }
    }

    String received_version = wrap.get("v").asRawValue().getString();
    if (!received_version.equals(PROTOCOL_VERSION)) {
      throw new UnknownMessage("Invalid protocol versions: actual " + PROTOCOL_VERSION + " / received " + received_version);
    }
<%
  if Env['use_cookies']
    Env['cookie_names'].each do |cookie_name|
%>
    if (wrap.containsKey("_<%= cookie_name %>")) {
      CookieJar.set(CookieJar.<%= cookie_name.upcase %>_ID, toStoredCookie(wrap.get("_<%= cookie_name %>")));
    }<%
    end
  end
%>

    switch(wrap.get("type").asIntegerValue().getInt())
    {<% Env['declared_types'].each do |message| next unless Env['sendable_messages'].include?(message) %>
      case MDIMessages.ID_<%= message.upcase %>:
        return new MDIMessages.<%= message %>(wrap.get("msg").asMapValue());<% end %>
      default:
        throw new UnknownMessage("Unknown type" + wrap.get("type").asRawValue().getString() +".");
    }
  }

<% Env['declared_types'].each do |message| next unless Env['sendable_messages'].include?(message) %>

  public static BuffRef encode(MDIMessages.<%= message %> <%= message.downcase %>){
    HashMap<String,Object> hm = new HashMap<String,Object>();
    hm.put("v", PROTOCOL_VERSION);
    hm.put("type", MDIMessages.ID_<%= message.upcase %>);
    hm.put("msg", <%= message.downcase %>.toHash());

    <% if Env['use_cookies'] %>
    CookieJar.clean();<% Env['cookie_names'].each do |cookie_name|
      next unless Env['cookies'][cookie_name]['_send_with'].include?(message) %>
    if(CookieJar.has(CookieJar.<%= cookie_name.upcase %>_ID)){
      hm.put("_<%= cookie_name %>", Codec.toList(CookieJar.get(CookieJar.<%= cookie_name.upcase %>_ID)));
    }<% end %>

    <% end %>
    try {
      final MessagePack msgpack = new MessagePack();
      return new BuffRef(msgpack.write(hm));
    } catch (final IOException e) {
      e.printStackTrace();
    }
    return null;
  }<% end %>
}
