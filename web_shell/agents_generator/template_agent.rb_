#!/usr/bin/env ruby
#########################################################
# Xavier Demompion : xavier.demompion@mobile-devices.fr
# Mobile Devices 2013
#########################################################

require 'yaml'
require 'rspec'

# Framework to be standalone
require 'active_support/all'
if (require_relative '../../local_cloud/fake_cloud_lib/cloud_connect_sdk_module')
  include CC
end

# SDK framework
require_relative '../../agents_generator/cloud_agents_generated/sdk_utils/sdk_api'

# User code
require_relative '../../../cloud_agents/XX_PROJECT_NAME/initial'

# XX_PROJECT_NAME agent
class Agent_XX_CLEAN_PROJECT_NAME

  # Protogen
  if File.exist?("#{RH.generated_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")
    require_relative 'protogen_XX_PROJECT_NAME/protogen_apis'
  end

  # Project
  @AGENT_NAME = ''
  @CHANNEL = ['com.mdi.services.XX_PROJECT_NAME']

  def initialize() # constructor
    SDK.API.log.info("root path is = \"#{SDK.API.root_path}\"")

    @AGENT_NAME = 'XX_PROJECT_NAME'

    # Load dynamic channel
    @CHANNEL = SDK.API::get_channels

    @has_protogen = File.exist?("#{RH.generated_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")

    SDK.API.log.info("init as protogen=#{@has_protogen} with dynamic channel = \"#{@CHANNEL}\"")
  end

  ######### Messages delivered for the agent ###########################
  def handle_presence(presence)
    PUNK.start('msgPresence')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][0] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgPresence','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- PRESENCE '#{presence.type}'")
    PUNK.start('handle', 'handling presence ...')
    CC.logger.info("Server: handle_presence: pushing presence '#{presence.type}' of imei='#{presence.asset}' to agent 'XX_PROJECT_NAME'")
    new_presence_from_device(presence)
  end

  def handle_message(message)

    a_channel_is_valid = false
    @CHANNEL.each { |chan|
      if message.channel == chan
        a_channel_is_valid = true
      end
    }

    if !a_channel_is_valid
      return
    end

    PUNK.start('msgAgent')

    msg_type = ""
    begin
      SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][1] += 1
      SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1

      # decode content as base64 (vm mode)
      message.content = Base64.decode64(message.content)

      is_protogen = false

      if @has_protogen
        begin
          # protogen decode
          msg, cookies = ProtogenAPIs.decode(message)
          message.content = msg
          message.meta['protogen_cookies'] = cookies
          msg_type = msg.class

          is_protogen = true
        rescue Protogen::UnknownMessageType => e
          # direct run
          CC.logger.warn("Server: handle_message: unknown protogen message type: #{e.inspect}")
          raise e unless $allow_non_protogen
        rescue MessagePack::UnpackError => e
          CC.logger.warn("Server: handle_message: MessagePack unpack error, either the payload is corrupted or not a protogen message : (err=#{e.inspect})")
          raise e unless $allow_non_protogen
        end
      else # not @has_protogen
        raise "No Protogen defined" unless $allow_non_protogen
      end

      PUNK.end('msgAgent','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- MSG[#{crop_ref(message.id,4)}] '#{msg_type}'")

    rescue Exception => e
      CCS.print_ruby_exception(e)
      PUNK.end('msgAgent','ko','in',"AGENT:XX_PROJECT_NAMETNEGA <- MSG[#{crop_ref(message.id,4)}] '#{msg_type}'")
      return
    end


    # process
    PUNK.start('handle', 'handling message ...')
    if is_protogen

      CC.logger.info("Server: new protogen message of imei='#{message.asset}' to agent 'XX_PROJECT_NAME': #{message.content} ---------------------")
      ProtogenAPIs.process(self, message)
    else

      CC.logger.debug("Server: new standard message  of imei='#{message.asset}' to agent 'XX_PROJECT_NAME' ---------------------")
      new_msg_from_device(message)
    end

    message.id
  end

  def handle_track(track)
    PUNK.start('msgTrack')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][2] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgTrack','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- TRACK")

    PUNK.start('handle', 'handling track ...')
    CC.logger.info("Server: handle_track: pushing track of imei='#{track.asset}'' to agent 'XX_PROJECT_NAME' ---------------------")
    new_track_from_device(track)
  end

  def handle_order(order)
    #todo: test type, log on errors
    PUNK.start('msgOrder')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][3] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgOrder','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- ORDER '#{order.code}'")

    PUNK.start('handle', 'handling order ...')
    CC.logger.info("Server: handle_order: pushing order #{order.code} to agent 'XX_PROJECT_NAME' ---------------------")
    new_order(order)
  end

  # SDK Framework
  include Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME

  # Protogen
  include ProtogenAPIs if defined? ProtogenAPIs

  # User code
  include Initial_agent_XX_PROJECT_NAME

end
