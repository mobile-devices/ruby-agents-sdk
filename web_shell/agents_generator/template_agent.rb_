#########################################################
# Xavier Demompion : xavier.demompion@mobile-devices.fr
# Mobile Devices 2013
#########################################################

require 'yaml'

# Framework to be standalone
require 'active_support/all'
if (require_relative '../../local_cloud/fake_cloud_lib/cloud_connect_sdk_module')
  include CC
end
if (require_relative '../../local_cloud/API/sdk_stats')
  include SDK_STATS
end

# User code
require_relative '../../../cloud_agents/XX_PROJECT_NAME/initial'

# XX_PROJECT_NAME agent
class Agent_XX_PROJECT_NAME

  # Protogen
  if File.exist?("#{generated_rb_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")
    require_relative 'protogen_XX_PROJECT_NAME/protogen_apis'
  end

  # Project
  @AGENT_NAME = 'XX_PROJECT_NAME'
  @CHANNEL = ['com.mdi.services.XX_PROJECT_NAME']

  def initialize() # constructor
    log_debug("Agent_XX_PROJECT_NAME root path is = \"#{root_path}\"")

    # Load dynamic channel
    @CHANNEL = config['Dynamic_channel_str']

    if @CHANNEL.is_a? String
      @CHANNEL = ["#{@CHANNEL}","#{@AGENT_NAME}"]
    end

    if (@CHANNEL == nil) || (@CHANNEL.length == 0)
      @CHANNEL = ['com.mdi.services.XX_PROJECT_NAME']
    end
    @has_protogen = File.exist?("#{generated_rb_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")


    log_debug("Agent_XX_PROJECT_NAME init as protogen=#{@has_protogen} with dynamic channel = \"#{@CHANNEL}\"")
  end


  ######### Messages delivered for the agent ###########################
  def handle_presence(presence)
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][0] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.start('handle')
    CC.logger.info("Server: handle_presence: pushing presence '#{presence.type}' to agent XX_PROJECT_NAME ..................")
    new_presence_from_device(presence)
  end

  def handle_message(message)
    msg_type = ""

    a_channel_is_valid = false
    @CHANNEL.each { |chan|
      if message.channel == chan
        a_channel_is_valid = true
      end
    }
    return unless a_channel_is_valid

    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][1] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.start('handle')

    # decode content as base64
    message.content = Base64.decode64(message.content)

    is_protogen = false

    if @has_protogen
      begin
        # protogen decode
        msg, cookies = ProtogenAPIs.decode(message)
        message.content = msg
        message.meta['protogen_cookies'] = cookies
        msg_type = msg.class

        # do stats

        is_protogen = true
      rescue Protogen::UnknownMessageType => e
        # direct run
        is_protogen = false
        if $allow_non_protogen
          CC.logger.warn("Server: handle_message: unknown protogen message type: #{e.inspect}")
        else
          raise e
        end
      end
    else
      if !($allow_non_protogen)
        raise "No Protogen defined"
      end
    end

    CC.logger.debug("Server: message content is : \n #{message.content}")

    # process
    CC.logger.info("Server: handle_message: pushing message to agent XX_PROJECT_NAME ..................")
    if is_protogen
      treat_poi_request(message)
      #ProtogenAPIs.process(message)
    else
      new_msg_from_device(message)
    end

    msg_type
  end

  def handle_track(track)
    #todo: test type, log on errors
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][2] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.start('handle')
    CC.logger.info("Server: handle_track: pushing track to agent XX_PROJECT_NAME ..................")
    new_track_from_device(track)
  end

  def handle_order(order)
    #todo: test type, log on errors
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][3] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.start('handle')
    CC.logger.info("Server: handle_track: pushing order #{order.code} to agent XX_PROJECT_NAME ..................")
    new_order(order)
  end

  ########## Messages to devices #######################################

  #todo: implement send and reply for a CCS.Message


# require /include implémentation du send(maClass) from protogen génération
# send message : set channel as @CHANNEL[0]

  # def send_message_to_device(account, asset, content)
  #   #todo add try catch
  #   begin
  #     Message.new({
  #       asset:     asset,
  #       recipient: asset,
  #       sender:    '@@server@@',
  #       channel:   @CHANNEL[0],
  #       payload:   content.to_json
  #       }).push
  #   #note: for real wrapper : mock up account as bellow :
  #   #   account.messages.new({
  #   #     asset:     asset.imei,
  #   #     recipient: asset.imei,
  #   #     sender:    '@@server@@',
  #   #     channel:   @CHANNEL,
  #   #     payload:   content.to_json
  #   #     }, as: :agent).push
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['push_sent_to_device'] += 1
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_sent'] += 1
  #   rescue Exception => e
  #     CC.logger.error("Error on send_message_to_device")
  #     print_ruby_exeption(e)
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['err_on_push'] += 1
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_error'] += 1
  #   end
  # end

  # def reply_message_to_device(message, account, content)
  #   #idem, we build a Message then send it to rqueue
  #   begin
  #     #note: real wrapper will be : m.push('account' => account.name)
  #     m = message.reply("200#{content}")
  #     m.push('account' => account)
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['reply_sent_to_device'] += 1
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_sent'] += 1
  #   rescue Exception => e
  #     CC.logger.error("Error on reply_message_to_device")
  #     print_ruby_exeption(e)
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['err_on_reply'] += 1
  #     SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_error'] += 1
  #   end
  # end

  ############### Logger ###############################################
  def log_debug(str_msg)
    CC.logger.debug("Agent XX_PROJECT_NAME: #{str_msg}")
  end

  def log_info(str_msg)
    CC.logger.info("Agent XX_PROJECT_NAME: #{str_msg}")
  end

  def log_warn(str_msg)
    CC.logger.warn("Agent XX_PROJECT_NAME: #{str_msg}")
  end

  def log_error(str_msg)
    CC.logger.error("Agent XX_PROJECT_NAME: #{str_msg}")
  end

  ############### Redis ################################################
  def redis()
    @redis ||= Redis::Namespace.new('CCS:XX_PROJECT_NAME', :redis => CCS.redis)
  end

  ############### Config ###############################################
  #note: real wrapper wille have a .yml for each agent in a same folder
  def config()
    @config ||= begin
      if File.exist?("#{root_path}/config/XX_PROJECT_NAME.yml")
        @config = YAML::load(File.open("#{root_path}/config/XX_PROJECT_NAME.yml"))['development']
      elsif File.exist?("#{root_path}/config/XX_PROJECT_NAME.yml.example")
        @config = YAML::load(File.open("#{root_path}/config/XX_PROJECT_NAME.yml.example"))['development']
      else
        log_warn("NO CONFIG FILE FOUND in #{root_path}/config")
        @config = Hash.new
      end
    rescue Exception => e
      log_error("ERROR while loading configuration")
      print_ruby_exeption(e)
    end
  end

  ############### Path ################################################

  def root_path()
    'XX_PROJECT_ROOT_PATH'
  end

  ######################################################################

  include ProtogenAPIs if defined? ProtogenAPIs

  include Initial_agent_XX_PROJECT_NAME

end
