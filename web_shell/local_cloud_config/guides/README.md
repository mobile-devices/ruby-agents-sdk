# @markup markdown
# @title Getting started
# @author Xavier Demorpion

# Getting started #

The SDK VM runs two local servers:

- on http://0.0.0.0:5000, you will find a graphical interface that allows you to easily
  - manage your agents
  - access stats about the running agents
  - access the logs generated by your agent or the VM
  - run your automated tests and see their results (with a nice export feature)
- on http://0.0.0.0:5001 runs the SDK agents server.

Your workspace is the **ruby-workspace** folder found in your VM folder. You can't move this folder, but you can symlink it if you want.

## Creating your first agent ##

1. Start your VM with vagrant, you must have done it to view this page :)
2. Open the page <http://0.0.0.0:5000/> in your favorite browser.
3. In the empty field in the column "Agent name", enter your agent name, then click "Create agent".

That's it. The SDK automatically created a new folder in the workspace with your agent base structure.
Let's take a look at it.

## Agent structure ##

Here is the base agent structure:

```
    ruby-workspace
    `-- my_agent
        |-- initial.rb
        |-- Gemfile
        |-- config/
        |   |-- my_protocol.protogen
        |   |-- schedule.rb
        |   `-- my_agent.yml
        |-- protogen/
        |-- modules/
        `-- README.md

```

So, what are these files for?

- *initial.rb* is the entry point of your agent. You can not rename this file nor move it.
- *Gemfile* is a standard... gemfile where you put the ruby gems you want to use with your agent.
- *my_protocol.protogen* is where you define the communication protocol between your devices and the server. See the Protogen guide for more information.
- *scheduled.rb* is where you define some tasks to be executed on a regular basis (see the "Scheduled tasks" guide for more information).
- *my_agent.yml* is an example configuration file. A user-friendly explanation of YAML can be found [on Wikipedia](http://en.wikipedia.org/wiki/YAML).
- *modules* is a source folder where you can add additional Ruby files
- *README.md* is a place where you can put information about your agent, because documentation is mandatory, isn't it?

## The basics ##

Now let's open this *initial.rb* file:

``` ruby
module Initial_agent_my_agent

  def new_presence_from_device(presence)
    # Write your code here
  end

  def new_msg_from_device(msg)
    # Write your code here
  end

  def new_track_from_device(track)
    # Write your code here
  end

  def new_order(order)
    # Write your code here
  end

end
```

These methods are callbacks for several events your agent can suscribe to. You can not change the name of the enclosing module.

### Presences, tracks and messages

* A `presence` is sent by the device at each connection or disconnection. For instance, listening to presences allow you to send messages to device at every device connection.
* A `track` is a collection of data recorded by the device and sent to the server, according to the device configuration. The structure of a track on the wire is optimized to limit bandwith usage. Use tracks to collect device speed, position, battery level, or other car data. The complete description of the tracking system is out of the scope of this documentation.
* A `message` is a generic container for data. Unlike tracks that serves a specific purpose and are only sent by the device to the server, messages can be used for two-way communication with the device.

### Order

An order is an event sent to your agent when it needs to perform a task. These orders are sent according to your scheduled orders configuration in `config/scheduled.rb`.

## Agent configuration

Now let's have a look at `config/my_agent.yml`.

```
default: &DEFAULT
  dynamic_channel_str: com.mdi.services.my_agent
  subscribe_presence: false
  subscribe_message: false
  subscribe_track: false
  subscribe_collection: false
  subscribe_cloud_event: false

development: *DEFAULT
production: *DEFAULT
```

The `suscribe_presence`, `suscribe_message`, `suscribe_track` attributes are straightforward: if you are insterested in being notified for these, just set the suscribe value to `true`.

The `dynamic_channel_str` is either a string a an array that indicates on which channel(s) your agent is listening to. By convention, your agent will send messages on the first channel it is listening to.

(Note that, in a production environment, the channel must actually exist to be used, ie you must create it with the cloud API interface for your account. But we do not need to look into that right now, as we are in a development environment). 

The other two suscribe parameters are used for yet unimplemented features so you can ignore them for now.

## Your first agent

Time to write some code. Let's start by something simple (but useless) : an "echo" agent that replies back to the device with any message it receives.

If you followed the above steps, you should already have an agent named "my_agent" with a basic structure. We need to do two things:

1. In `config/my_agent.yml`,set `subscribe_message` to `true`
2. In `initial.rb`, add code for the `new_msg_from_device` callback.

```
  def new_msg_from_device(msg)
    user_api.mdi.dialog.device_gate.reply(msg, msg.content)
  end
```

Done.

### What is this `user_api` stuff?

Depending on the incoming message, the environment your agent is running on, and other parameters, your agent may not be able to access the same APIs. The user_api object, automagically created for you, holds dynamic API whose behaviour will change depending on the context.

That means that you do not need to configure the API you are using. For instance, the above `device_gate` was lazily instantiated with the correct configuration for your message.

### All right, where do I find more documentation about the available API?

Look at the documentation for {UserApis::MdiClass}. You will find the list of API under the "namespace" `user_api.mdi`. From here, you can navigate the documentation to find the object you are looking for. Remember that you do not need to instantiate any class in the `UserApi` module, this is done for you.

### I need a logger!

Let's find it together. Let's go at the documentation for the class {UserApis::MdiClass}. The documentation for {UserApis::MdiClass#tools} says we will find a logger here. And indeed, we can see by following the links that a logger is available: `user_api.mdi.tools.log` (the corresponding class being {UserApis::Mdi::Tools::LoggerClass}).

### I need the documentation for the received messages, tracks and presences!

Here it is: {UserApis::Mdi::Dialog::MessageClass}, {UserApis::Mdi::Dialog::TrackClass}, {UserApis::Mdi::Dialog::PresenceClass}

## Running your agent ##

Go to the ["SDK Agents"](http://0.0.0.0:5000) tab in your browser. Click on the red "Unmounted" button in front of your agent name. The button now displays "Mounted" which means that your agent is marked to be used next time the SDK agents server is restarted.

To start or reboot the server, click the blue (or red, if something went wrong) button in the top-right corner.

## Checking the logs ##

To be sure the SDK agents server correctly started, go to the ["Server Log"](http://0.0.0.0:5000/logSdkAgentsPunk#endlog) tab. Here you'll find a nice and colorful display of the logs written by the server. You should see a "ready to use!" item in the left column if everything went OK. Clicking on an item will display the corresponding detailed logs.

You will see in these logs the events received by the server, the messages sent to the device...

Should you ever need to access the raw logs generated by the SDK, you can find them in `ruby_workspace/sdk_logs`.

## Keep your code clean ##

To keep your code well organized, it is recommanded that you put most of your code in a `modules` subfolder (and you can of course create subfolders in this subfolder...). You can define your own modules and classes to keep your code clean.

## What's next? ##

### Agent guidelines ###

To be accepted, your agents must follow some rules described {file:guide/guidelines.md in the guidelines}. Notably, your agent must be **stateless**, so you must not use global variables other than the ones provided to you by the SDK (do not declare global variables, do not use class variables, ...).

Keep in mind that your agent can be restarted at any time, that its Redis cache could be flushed at any moment, that several instances of your agent could be running at the same time but only one will receive a given message...

### Using the API ###

The SDK provides you with an API with methods to help you sending messages to devices, writing logs, accessing configuration options, ... Check the related guide {file:guide/sdk_api.md here}.

### Unit testing ###

The SDK integrates the [Rspec](http://rubydoc.info/gems/rspec-core/file/README.md) testing framework. The web interface has a tab named ["Unit tests"](http://0.0.0.0:5000/unit_tests) where you can easily run your Rspec tests, see the results live, and save them for future reference.

You can find more information on how to test your agents {file:guide/tests.md in this guide}.

### Protogen ###

Protogen is the MDI protocol generator tool. You give it a description of the communication protocol between a device and a server, and it generates all the communication layer code for you (taking care of all the little pesky details such as controlling the size of the messages or serializing efficiently your data).

And it is simple to use: see {file:guides/protogen.md this guide} for details.