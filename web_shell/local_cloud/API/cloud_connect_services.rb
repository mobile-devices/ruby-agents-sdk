#########################################################
# Xavier Demompion : xavier.demompion@mobile-devices.fr
# Mobile Devices 2013
#########################################################


# @api public
# This module defines the events an agent can receive, along a few utilities methods.
# This module does not have any agent-specific configuration.
module CloudConnectServices

  #============================== CLASSES ========================================

  # An event received when a device change its connection status
  # @api public
  class Presence < Struct.new(:asset, :time, :bs, :type, :reason, :account, :meta)

    # ---
    # Presence hash :
    # "meta", a map with some meta data, generally none.
    # "payload", a map with :
    #   asset : imei of the device
    #   time : timestamp of the event
    #   bs : binary server source
    #   type : 'connect' or 'reconnect' or 'disconnect'
    #   reason : reason for the event
    # "account" (account name type String).
    # +++

    # @!attribute [rw] asset
    #   @api public
    #   @return [String] the IMEI of the device or other similar unique identifier.

    # @!attribute [rw] time
    #   @api public
    #   @return [Fixnum] a timestamp indicating when this event was received.

    # @!attribute [rw] bs
    #   @api public
    #   @return [String] the identifier of the source binary server (entry point of the MDI cloud).

    # @!attribute [rw] type
    #   @api public
    #   @return [String] 'connect', 'reconnect' or 'disconnect'.

    # @!attribute [rw] reason
    #   @api public
    #   @return [String] the reason for the event.

    # @!attribute [rw] meta
    #   @api public
    #   @return [Hash] some meta data associated with the event (may be empty).

    # @!attribute [rw] account
    #   @api public
    #   @return [String] the account name used.

    # Constructor.
    #
    # Hash representation of a presence:
    #
    #   ``` ruby
    #   {
    #   meta => {
    #     'account' => self.account,
    #   },
    #   payload => {
    #     'asset' => self.asset,
    #     'time' => self.time,
    #     'bs' => self.bs,
    #     'type' => self.type,
    #     'reason' => self.reason
    #   }
    #   ```
    #
    def initialize(struct)
      self.meta = struct['meta']
      payload = struct['payload']
      self.asset = payload['asset']
      self.time = payload['time']
      self.bs = payload['bs']
      self.type = payload['type']
      self.reason = payload['reason']
      self.account = meta['account']

      if type != 'connect' && type != 'reconnect' && type != 'disconnect' && type != 'failed_connect'
        raise "Wrong type of presence : #{type}"
      end
    end

    # Returns a hash representation of the event.
    # See the constructor documentation for the format.
    # @return a hash representation of the event.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['meta'] = self.meta
      r_hash['payload'] = {
        'asset' => self.asset,
        'time' => self.time,
        'bs' => self.bs,
        'type' => self.type,
        'reason' => self.reason
      }
      r_hash.delete_if { |k, v| v.nil? }
    end

  end

  # A class that represents a standard message. Used in the DeviceGate and CloudGate APIs for instance.
  class Message < Struct.new(:id, :parent_id, :thread_id, :asset, :sender, :recipient, :type, :recorded_at, :received_at, :channel,:account, :meta, :content, :cookies)

    # ---
    # Message Source
    # "meta", a map with some meta data, generally none.
    # "payload", a map with :
    #   id : tmp id from the device
    #   asset : imei of device
    #   sender : Sender identifier (can be the same as the asset)
    #   recipient : Recipient identifier (can be the same as the asset)
    #   type : 'message'
    #   recorded_at : timestamp
    #   received_at : timestamp
    #   channel : string channel
    #   payload : content
    # "account" (account name type String).
    # +++


    # @!attribute [rw] id
    #   @api public
    #   The unique ID of the message. If the message comes from the device, this is a temporary ID set by the device.
    #   The server do not use those temporary IDs; instead, it will generate a new ID
    #   and will inform the device of this new ID in the ACK message.
    #   If the message is generated by the server, this ID is not temporary.
    #   @return [Fixnum] the unique ID of the message.

    # @!attribute [rw] asset
    #   @api public
    #   @return [String] the IMEI (or similar unique identification number) of the device who
    #     either sent this message or to whom this message is destined.

    # @!attribute [rw] sender
    #   @api public
    #   @return [String] the sender identifier; will often be the same as the asset if this message comes
    #     from a device, or `@@server` if the message comes from the server.

    # @!attribute [rw] recipient
    #   @api public
    #   @return [String] recipient identifier, often the same as the asset.

    # @!attribute [r] type
    #   @api public
    #   @return [String] always "message".

    # @!attribute [rw] recorded_at
    #   @api public
    #   @return [Fixnum] a timestamp indicating when this message was created.

    # @!attribute [rw] received_at
    #   @api public
    #   @return [Fixnum] a timestamp indicating when this message was received.

    # @!attribute [rw] channel
    #   @api public
    #   @return [String] the channel on which this message was received or will be emitted.

    # @!attribute [rw] payload
    #   @api public
    #   @return [String] the content of the message.

    # @!attribute [rw] account
    #   @api public
    #   @return [String] the account name used by the sender.

    # @!attribute [rw] meta
    #   @api public
    #   @return [Hash] meta data associated with this message; often empty or `nil`.

    # @!attribute [rw] parent_id
    #   @api public
    #   @return the ID of the parent message if this message is a response to another message.

    # @!attribute [rw] cookies
    #   @api public
    #   @return Protogen cookies (may be `nil`)

    # @!attribute [rw] content
    #   @api public
    #   @return content of the message. Can be a Protogen object, or a regular String.

    # @param [Hash] struct messages can be represented as a raw hash with the following format:
    #
    #   ``` ruby
    #   {
    #   'meta' => self.meta,
    #   'payload' => {
    #     'payload' => self.content,
    #     'channel' => self.channel,
    #     'parent_id' => self.parent_id,
    #     'thread_id' => self.thread_id,
    #     'id' => self.id,
    #     'asset' => self.asset,
    #     'sender' => self.sender,
    #     'recipient' => self.recipient,
    #     'type' => self.type,
    #     'recorded_at' =>  self.recorded_at,
    #     'received_at' =>  self.received_at,
    #     'channel' =>  self.channel
    #   }
    #   ```
    #
    # @api private
    def initialize(struct = nil)
      if struct.blank?
        self.meta = {}

        self.parent_id = nil
        self.thread_id = nil
        self.asset = nil
        self.sender = '@@server@@'
        self.recipient = nil
        self.type = 'message'
        self.recorded_at = 007
        self.received_at = 007

        begin
          self.channel = SDK.API.get_channels[0]
        rescue Exception => e
          self.channel = "unknown"
        end

        self.content = nil

      else

        self.meta = struct['meta']
        payload = struct['payload']

        self.content = payload['payload']
        self.id = payload['id']
        self.parent_id = payload['parent_id']
        self.thread_id = payload['thread_id']
        self.asset = payload['asset']
        self.sender = payload['sender']
        self.recipient = payload['recipient']
        self.type = payload['type']
        self.recorded_at = payload['recorded_at']
        self.received_at = payload['received_at']
        self.channel = payload['channel']

        if meta.is_a? Hash
          self.account = meta['account']
          self.cookies = meta['protogen_cookies']
        end

        if self.type != 'message' && self.type != 'ack'
          raise "Message: wrong type of message : '#{type}'"
          return
        end

        if self.id.blank?
          self.id = CC.indigen_next_id
        end

      end
    end

    # Hash representation of a message.
    #
    #   ``` ruby
    #   {'meta' => self.meta,
    #   'payload' => {
    #     'payload' => self.content,
    #     'channel' => self.channel,
    #     'parent_id' => self.parent_id,
    #     'thread_id' => self.thread_id,
    #     'id' => self.id,
    #     'asset' => self.asset,
    #     'sender' => self.sender,
    #     'recipient' => self.recipient,
    #     'type' => self.type,
    #     'recorded_at' =>  self.recorded_at,
    #     'received_at' =>  self.received_at,
    #     'channel' =>  self.channel
    #   }
    #   ```
    #
    # @return [Hash] a hash representing this message.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['meta'] = self.meta
      r_hash['meta'] = {} if r_hash['meta'] == nil
      r_hash['meta']['account'] = self.account
      r_hash['payload'] = {
        'payload' => self.content,
        'channel' => self.channel,
        'parent_id' => self.parent_id,
        'thread_id' => self.thread_id,
        'id' => self.id,
        'asset' => self.asset,
        'sender' => self.sender,
        'recipient' => self.recipient,
        'type' => self.type,
        'recorded_at' =>  self.recorded_at,
        'received_at' =>  self.received_at,
        'channel' =>  self.channel
      }
      r_hash['meta'].delete_if { |k, v| v.nil? }
      r_hash['payload'].delete_if { |k, v| v.nil? }
      r_hash
    end

    # Pushes the message to the device without any preliminary setup.
    # Useful if you want to do all the setup yourself.
    # @api private
    def fast_push
      CC.push(self.to_hash)
    end

    # Sends this message to the device, using the current message configuration.
    #
    # It will not do any Protogen-related stuff before sending the message.
    #
    # This method will set the `received_at` field to `Time.now.to_i`. Will also set the sender to `@@server@@` if not exists.
    #
    # If the method parameters are not defined the current values stored in the message will be used.
    #
    # @param [String] asset the IMEI of the device or other similar unique identifier.
    # @param [Account] account the account name to use.
    # @api private
    def push(asset = nil, account = nil)
        if !(self.content.is_a? String)
          raise "message content must be of type String (got #{self.content.class.name})"
        end

        # set asset unless nil
        self.asset = asset unless asset.nil?
        self.recipient = asset unless asset.nil?

        # set acount unless nil
        self.account = account unless account.nil?

        # set sender if not defined (ie a direct push)
        self.sender ||= '@@server@@'

        # set received_at
        self.received_at = Time.now.to_i

        self.fast_push
    end

  end

  # Track data sent by a device.
  class Track < Struct.new(:id, :asset, :latitude, :longitude, :recorded_at, :received_at, :data, :account, :meta)

    # ---
    # Track Source :
    # "meta", a map with some meta data, generally none.
    # "payload", a map with :
    #    id : tmp id from the device
    #    asset : imei of device
    #    latitude
    #    longitude
    #    recorded_at
    #    received_at
    #    field1
    #    field2
    #    ...
    # "account" (account name type String).
    # +++

    # @!attribute [rw] id
    #   @api public
    #   @return [Fixnum] the temporary message ID sent by the device.

    # @!attribute [rw] asset
    #   @api public
    #   @return [String] the IMEI of the device who sent the message.

    # @!attribute [rw] meta
    #   @api public
    #   @return [Hash] meta data associated with the track, generally empty or `nil`.

    # @!attribute [rw] data
    #   @api public
    #   @return [Hash] a hash of track data with the following fields: latitude, longitude, recorded_at, received_at, field1, field2, ...

    # @!attribute [rw] account
    #   @api public
    #   @return [String] the account name used.

    # Constructor.
    # The hash format of a track is:
    #
    #   ```ruby
    #     {
    #       'meta' => self.meta,
    #       'payload' => {
    #       'id' => self.id,
    #       'asset' => self.asset,
    #       'data' => self.data
    #     }
    #   ```
    #
    # @param [Hash] struct this hash must have the above format.
    def initialize(struct)

      self.meta = struct['meta']
      payload = struct['payload']

      self.id = payload['id']
      self.asset = payload['asset']
      self.account = self.meta['account']

      self.latitude = payload['latitude']
      self.longitude = payload['longitude']
      self.recorded_at = payload['recorded_at']
      self.received_at = payload['received_at']
      self.data = {}
      payload.keys.each do |k, v|
        field_name = CCSI.track_mapping.str_value_of(k)
        if field_name != nil
          self.data[field_name] = v # todo: operate a conversion of the value ?
          CC.logger.debug("found field #{k} (name='#{field_name}') and value='#{v}'")
        end
      end
    end

    # @return [Hash] a hash representation of this event. See constructor documentation for the format.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['meta'] = self.meta
      r_hash['payload'] = {
        'id' => self.id,
        'asset' => self.asset,
        'recorded_at' => self.recorded_at,
        'received_at' => self.received_at,
        'latitude' => self.latitude,
        'longitude' => self.longitude
      }
      # add fields
      self.data.each do |k, v|
        field_code = CCSI.track_mapping.int_value_of(k)

        if field_code != nil
          CC.logger.debug("Adding field #{k} (int=#{field_code}) value=#{v}")
          r_hash['payload'][field_code] = v  # todo: operate a conversion of the value ?
        else
          CC.logger.error("Track to_hash field #{k} not found !")
          CC.logger.error("Available are : #{CCSI.track_mapping.fetch_map}")
          raise "Track to_hash field #{k} not found !"
        end
      end

      r_hash['meta'].delete_if { |k, v| v.nil? }
      r_hash['payload'].delete_if { |k, v| v.nil? }
      r_hash
    end
  end

  # An event sent when a scheduled order is going to be executed.
  class Order < Struct.new(:agent, :code, :params)

    # @!attribute [rw] agent
    #   @api public
    #   @return [String] the name of the agent which requested this order

    # @!attribute [rw] code
    #   @api public
    #   @return [String] the order name

    # @!attribute [rw] params
    #   @api public
    #   @return [Hash] parameters of the order

    # Constructor.
    #
    # Hash format of an order:
    #
    # ``` ruby
    # {
    # 'agent' => self.agent,
    # 'order' => self.order,
    # 'params' => self.params
    # }
    # ```
    #
    # @api private
    def initialize(struct)
      self.agent = struct['agent']
      self.code = struct['order']
      self.params = struct['params']

      #todo: test nullity or agent and order?

      if !(RH.running_agents.include?(self.agent))
        raise AgentNotFound , "Server: agent #{self.agent} is not running on this bay"
      end
    end

    # @return a hash representation of this order. See constructor documentation for format.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['agent'] = self.agent
      r_hash['order'] = self.order
      r_hash['params'] = self.params
      r_hash.delete_if { |k, v| v.nil? }
    end
  end

  # @api private
  class Log

    def initialize(header_txt)
      @head = header_txt
    end

    def debug(str_msg)
      CC.logger.debug("#{@head}#{str_msg}")
    end

    def info(str_msg)
      CC.logger.info("#{@head}#{str_msg}")
    end

    def warn(str_msg)
      CC.logger.warn("#{@head}#{str_msg}")
    end

    def error(str_msg)
      CC.logger.error("#{@head}#{str_msg}")
    end

  end

  # @api private
  class AgentNotFound < StandardError
  end

  #============================== METHODS ========================================

  # @api private
  def self.print_ruby_exception(e)
    stack=""
    e.backtrace.take(20).each { |trace|
      stack+="  >> #{trace}\n"
    }
    CC.logger.error("  RUBY EXCEPTION >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n >> #{e.inspect}\n\n#{stack}\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
  end



end


CCS = CloudConnectServices
