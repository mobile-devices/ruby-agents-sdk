#!/usr/bin/env ruby
#########################################################
# Xavier Demompion : xavier.demompion@mobile-devices.fr
# Mobile Devices 2013
#########################################################

require 'yaml'
require 'rspec'

# Framework to be standalone
require 'active_support/all'
if (require_relative '../../local_cloud/fake_cloud_lib/cloud_connect_sdk_module')
  include CC
end

# User code
require_relative '../../../cloud_agents/XX_PROJECT_NAME/initial'

# Generated SDK API (the folder is added to $LOAD_PATH in generated code so we
# don't need require_relative)
require 'sdk_api'

require_relative '../../local_cloud/API/json_tests_writer'

# XX_PROJECT_NAME agent
class Agent_XX_CLEAN_PROJECT_NAME

  # Protogen
  if File.exist?("#{RH.generated_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")
    require_relative 'protogen_XX_PROJECT_NAME/protogen_apis'
  end

  # Project
  @AGENT_NAME = ''
  @CHANNEL = ['com.mdi.services.XX_PROJECT_NAME']

  def initialize() # constructor
    SDK.API.log.info("root path is = \"#{SDK.API.root_path}\"")

    @AGENT_NAME = 'XX_PROJECT_NAME'

    # Load dynamic channel
    @CHANNEL = SDK.API::get_channels

    @has_protogen = File.exist?("#{RH.generated_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")

    SDK.API.log.info("init as protogen=#{@has_protogen} with dynamic channel = \"#{@CHANNEL}\"")
  end

  ######### Messages delivered for the agent ###########################
  def handle_presence(presence)
    PUNK.start('msgPresence')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][0] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgPresence','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- PRESENCE '#{presence.type}'")
    PUNK.start('handle', 'handling presence ...')
    CC.logger.info("Server: handle_presence: pushing presence '#{presence.type}' of imei='#{presence.asset}' to agent 'XX_PROJECT_NAME'")
    new_presence_from_device(presence)
  end

  def handle_message(message)

    PUNK.start('msgAgent')
    a_channel_is_valid = false
    @CHANNEL.each { |chan|
      if message.channel == chan
        a_channel_is_valid = true
      end
    }

    if !a_channel_is_valid
      CC.logger.error("Channel #{message.channel} not found in #{@CHANNEL}")
      PUNK.end('msgAgent','ko','in',"AGENT:XX_PROJECT_NAMETNEGA DROP MSG[#{crop_ref(message.id,4)}] '#{msg_type}' because channel is bad")
      return
    end

    msg_type = ""
    begin
      SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][1] += 1
      SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1

      # decode content as base64 (vm mode)
      message.content = Base64.decode64(message.content)

      is_protogen = false

      if @has_protogen
        begin
          # protogen decode
          msg, cookies = ProtogenAPIs.decode(message)
          message.content = msg
          message.meta['protogen_cookies'] = cookies
          msg_type = msg.class

          is_protogen = true
        rescue Protogen::UnknownMessageType => e
          # direct run
          CC.logger.warn("Server: handle_message: unknown protogen message type: #{e.inspect}")
          raise e unless $allow_non_protogen
        rescue MessagePack::UnpackError => e
          CC.logger.warn("Server: handle_message: MessagePack unpack error, either the payload is corrupted or not a protogen message : (err=#{e.inspect})")
          raise e unless $allow_non_protogen
        end
      else # not @has_protogen
        raise "No Protogen defined" unless $allow_non_protogen
      end

      PUNK.end('msgAgent','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- MSG[#{crop_ref(message.id,4)}] '#{msg_type}'")

    rescue Exception => e
      CCS.print_ruby_exception(e)
      PUNK.end('msgAgent','ko','in',"AGENT:XX_PROJECT_NAMETNEGA <- MSG[#{crop_ref(message.id,4)}] '#{msg_type}'")
      return
    end


    # process
    PUNK.start('handle', 'handling message ...')
    if is_protogen

      CC.logger.info("Server: new protogen message of imei='#{message.asset}' to agent 'XX_PROJECT_NAME': #{message.content} ---------------------")
      ProtogenAPIs.process(self, message)
    else

      CC.logger.debug("Server: new standard message  of imei='#{message.asset}' to agent 'XX_PROJECT_NAME' ---------------------")
      new_msg_from_device(message)
    end

    message.id
  end

  def handle_track(track)
    PUNK.start('msgTrack')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][2] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgTrack','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- TRACK")

    PUNK.start('handle', 'handling track ...')
    CC.logger.info("Server: handle_track: pushing track of imei='#{track.asset}'' to agent 'XX_PROJECT_NAME' ---------------------")
    new_track_from_device(track)
  end

  def handle_order(order)
    #todo: test type, log on errors
    PUNK.start('msgOrder')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][3] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgOrder','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- ORDER '#{order.code}'")

    PUNK.start('handle', 'handling order ...')
    CC.logger.info("Server: handle_order: pushing order #{order.code} to agent 'XX_PROJECT_NAME' ---------------------")
    new_order(order)
  end

  # def run_tests()
  #   test_path = "#{SDK.API::root_path}/tests"
  #   unless File.directory?(test_path)
  #     CC.logger.info("No test directory found for agent 'XX_PROJECT_NAME', skipping tests.")
  #     return
  #   end
  #   output_file_path = "/home/vagrant/ruby_workspace/sdk_logs/tests_XX_CLEAN_PROJECT_NAME.log"
  #   RSpec::Core::Runner.run([test_path,
  #       "--require", "/home/vagrant/ruby-agents-sdk/web_shell/local_cloud/API/json_tests_writer.rb", "--format", "JsonTestsWriter"],
  #       $stderr, output_file_path)
  # end

# keep commented code until RAgent developped

  # def send_message_to_device(account, asset, content)
  #   #todo add try catch
  #   begin
      # Message.new({
      #   asset:     asset,
      #   recipient: asset,
      #   sender:    '@@server@@',
      #   channel:   @CHANNEL[0],
      #   payload:   content.to_json
      #   }).push
  #   #note: for real wrapper : mock up account as bellow :
  #   #   account.messages.new({
  #   #     asset:     asset.imei,
  #   #     recipient: asset.imei,
  #   #     sender:    '@@server@@',
  #   #     channel:   @CHANNEL,
  #   #     payload:   content.to_json
  #   #     }, as: :agent).push

  include Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME

  include ProtogenAPIs if defined? ProtogenAPIs

  include Initial_agent_XX_PROJECT_NAME

end
