Dir["<%= File.join(Env['user_callbacks'], '*.rb')%>"].each do |file|
  require_relative file
  CC.logger.debug("Protogen: importing user defined callbacks in #{file}")
end

module Protogen_<%= Env['agent_name'] %>

  module Protogen

    module Sequences

      class Sequence

        attr_accessor :shots

        def initialize(id, shots)
          @shots = shots
          @id = id
        end

        def run_callback_by_id(id, *args)
          @shots[id].received_callback.call(*args)
        end

        def continue(current_message)
          unless @id == current_message.content.protogen_meta_data['protogen_sequence_id']
            raise "Protogen: unvalid sequence id: got #{current_message.content.protogen_meta_data['protogen_sequence_id']}, expected #{@id}"
          end
          # todo: check current message type
          shot_id = current_message.content.protogen_meta_data['protogen_shot_id']
          current_message.content.cookies = current_message.meta['protogen_cookies']
          CC.logger.info("Protogen: processing shot #{shot_id} of sequence #{@id}")
          begin
            result = run_callback_by_id(shot_id, current_message)
          rescue Exception => e
            error_msg = ProtogenMessages::ServerError.new
            error_msg.info = "The server encountered an error when processing the device message: #{e.class.name} #{e.message}"
            error_msg.protogen_meta_data['protogen_sequence_id'] = @id
            error_msg.protogen_meta_data['protogen_shot_id'] = shot_id
            CC.logger.error("A user callback raised an exception. Answering to the device with an error message and aborting sequence.")
            Sdk_api_<%= Env['agent_name'] %>::SDK::API.device_gate.reply(current_message, error_msg)
            raise e
          end
          next_shots = @shots[shot_id].next_shots
          if next_shots.size > 0 # this is not the end of the sequence
            CC.logger.info("Protogen: callback returned an object of type #{result.class.to_s}")
            next_shots.each do |next_shot_id|
              next_shot = @shots[next_shot_id]
              if result.class == next_shot.message_type
                result.protogen_meta_data['protogen_sequence_id'] = @id
                result.protogen_meta_data['protogen_shot_id'] = next_shot.id
                Sdk_api_<%= Env['agent_name'] %>::SDK::API.device_gate.reply(current_message, result, result.cookies)
                CC.logger.info("Protogen: continuing sequence #{@id}")
                return
              end
            end
            # if we reach this point, the return type of the callback is not one of the possible next shots: error
            raise "Protogen: The callback for sequence #{@id} shot #{shot_id} did not return the expected message type: expected one of #{next_shots.map{ |next_shot| next_shot.message_type }.inspect}, got #{result.class}. Aborting sequence."
          else
            CC.logger.info("Protogen: sequence #{@id} complete")
          end
        end

      end

      class Shot

        attr_accessor :message_type
        attr_reader :way
        attr_accessor :received_callback
        attr_accessor :id
        attr_accessor :next_shots

        # next_shots is an array of shots id that can follow this shot
        def initialize(id, message_type, way, next_shots)
          @id = id
          @message_type = message_type
          @received_callback = nil
          @way = way
          @next_shots = next_shots
        end

      end

      def self.continue_sequence(message)
        CC.logger.debug(message.to_hash.inspect)
        sequence_id = message.content.protogen_meta_data['protogen_sequence_id']
        if sequence_id.nil?
          raise "Incoming Protogen message has no set sequence_id, dropping it"
        end
        get_sequence(sequence_id).continue(message)
      end

      # Retrieve the toServer sequence associated with a given id
      def self.get_sequence(sequence_id)
        unless defined? @@sequences
          @@sequences ||= []
          <% Env['sequences'].each do |sequence_name, sequence_def| %>
            shots = []
            <% sequence_def['shots'].each do |shot_name, shot|
              if shot.has_key?('next_shots') %>
              shot = Shot.new(<%= shot['id'] %>, Protogen::Messages::<%= shot['message_type'] %>, '<%= shot['way']%>', <%= shot['next_shots'].map{ |next_shot| sequence_def['shots'][next_shot]['id'] } %>)
              <% else -%>
              shot = Shot.new(<%= shot['id'] %>, Protogen::Messages::<%= shot['message_type'] %>, '<%= shot['way']%>', [])
              <% end
                 if shot['way'] == 'toServer' %>
              shot.received_callback = Proc.new {|message| <%= sequence_name %>Callbacks::<%= shot['received_callback'] %>(message)}
              <% end -%>
              shots << shot
            <% end %>
              @@sequences << Sequence.new(<%= sequence_def['id'] %>, shots)
          <% end %>
          end
        @@sequences[sequence_id]
      end

      <% Env['sequences'].reject {|sequence_name, sequence_definition| sequence_definition['shots'][sequence_definition['first_shot']]['way'] == 'toServer'}.each do |sequence_name, sequence_definition| %>
      def self.start<%= sequence_name %>Sequence(message, asset, account)
        if message.class != Protogen::Messages::<%= sequence_definition['shots'][sequence_definition['first_shot']]['message_type'] %>
          raise "Impossible to start the sequence <%= sequence_name %> with a message of type #{message.class.to_s} (expected Protogen::Messages::<%= sequence_definition['shots'][sequence_definition['first_shot']]['message_type'] %>), check your sequence definition."
        end
        message.protogen_meta_data['protogen_sequence_id'] = <%= sequence_definition['id'] %>
        message.protogen_meta_data['protogen_shot_id'] = 0
        Sdk_api_<%= Env['agent_name'] %>::SDK.API.device_gate.push(asset, account, message)
      end
      <% end %>

    end

  end

end
