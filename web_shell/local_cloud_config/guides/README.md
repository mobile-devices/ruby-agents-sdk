# @markup markdown
# @title Getting started
# @author Xavier Demorpion

# Getting started #

The SDK VM runs two local servers:

- on <http://0.0.0.0:5000>, you will find a graphical interface that allows you to easily
  - manage your agents
  - acces stats about the running agents
  - access the logs generated by your agent or the VM
  - run your automated tests and see their results (with a nice export feature)
- on http://0.0.0.0:5001 runs the SDK agents server.

Your workspace is the **ruby-workspace** folder found in your VM folder. You can't move this folder, but you can symlink it if you want.

## Creating your first agent ##

1. Start your VM with vagrant, you must have done it to view this page :)
2. Open the page <http://0.0.0.0:5000/> in your favorite browser.
3. In the empty field in the column "Agent name", enter your agent name, then click "Create agent".

That's it. The SDK automatically created a new folder in the workspace with your agent base structure.
Let's take a look at it.

## Agent structure ##

Here is the base agent structure:

```
    ruby-workspace
    `-- my_agent
        |-- initial.rb
        |-- Gemfile
        |-- config/
        |   |-- protogen.json
        |   |-- scheduled.rb
        |   `-- my_agent.yml.example
        |-- doc/
        |-- modules/
        `-- README.md

```

So, what are these files for?

- *initial.rb* is where the callbacks that allow communicating with the device are defined (more on this below). Consider it the entry point of your agent. You can not rename this file nor move it.
- *Gemfile* is a standard... gemfile where you put the ruby gems you want to use with your agent.
- *protogen.json* is where you define the communication protocol between your devices and the server. See the Protogen guide for more information.
- *scheduled.rb* is where you define some tasks to be executed on a regular basis (see the "Scheduled tasks" guide for more information).
- *my_agent.yml.example* is an example configuration file. Your own configuration file will be `my_agent.yml`. This file uses the YAML (the YAML reference can be found [here](http://www.yaml.org/) and a more user-friendly explanation of YAML can be found [on Wikipedia](http://en.wikipedia.org/wiki/YAML)).
- *doc* contains generated docs for your agent (notably generated Protogen documentation).
- *modules* is where you put your additional modules.
- *README.md* is a place where you can put information about your agent, because documentation is mandatory, isn't it?

## Writing callbacks to interact with a device ##

Now let's open this *initial.rb* file:

``` ruby
module Initial_agent_my_agent

  def new_presence_from_device(presence)
    # Write your code here
  end

  def new_msg_from_device(msg)
    # Write your code here
  end

  def new_track_from_device(track)
    # Write your code here
  end

  def new_order(order)
    # Write your code here
  end

  #################################################
  # Implement below callbacks defined in protogen #

end
```

To process messages sent by your device, you must implement these callbacks in a module named after your agent name (`"Initial_agent_<your_agent_name>"`).

- `new_presence_from_device` is called each time a device is connected or disconnected. `presence` is an object of the class {CloudConnectServices::Presence CCS::Presence} holding the data related to this event.
- `new_msg_from_device` is called each time an incoming message from the device is received. `msg` is an object of the class {CloudConnectServices::Message CCS::Message}.
- `new_track_from_device` is called each time track data from the device is received. `track` is an object of the class {CloudConnectServices::Track CCS::Track}.
- `new_order` is called each time a scheduled order is about to happen. `order` is an object of the class {CloudConnectServices::Order CCS::Order}.

Consult the documentation of each class to see what data is associated which each event.

If you want to reply to a message, you need to use the {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::MessageGate SDK.API::gate} object.

So for instance, if we were to write an agent that respond to each message it receives with the same content, the code would be:

``` ruby
module Initial_agent_my_agent

  def new_msg_from_device(msg)
    SDK.API.gate.reply(msg, msg.content)
  end

end
```

But before testing this highly useful agent, we need to configure it.

## Agent configuration ##

Your agent needs to suscribe to a channel and to some types of events (if you don't do this, your agent will simply ignore all events).
The file to edit is `config/my_agent.yml`. It uses the YAML syntax.

For instance here is a configuration file for our dummy agent.

``` ruby
default: &DEFAULT
  dynamic_channel_str: com.mdi.services.my_agent_channel
  subscribe_presence: false
  subscribe_message: true
  subscribe_track: false

development: *DEFAULT
```

With this configuration we drop all events that are not messages sent on the channel `"com.mdi.services.my_agent_channel"`.

Your agent can listen on several channels (`dynamic_channel_str: [com.mdi.services.my_agent_channel_1, com.mdi.services.my_agent_channel_2]`) but will always reply on the first configured channel.

## Running your agent ##

Go to the ["SDK Agents"](http://0.0.0.0:5000) tab in your browser. Click on the red "Unmounted" button in front of your agent name. The button now displays "Mounted" which means that your agent is marked to be used next time the SDK agents server is restarted.

To start or reboot the server, click the blue button in the top-right corner.

## Checking the logs ##

To be sure the SDK agents server correctly started, go to the ["Server Log"](http://0.0.0.0:5000/logSdkAgentsPunk#endlog) tab. Here you'll find a nice, readable and colorful display of the logs written by the server. You should see a "ready to use!" item in the left column if everything went OK. Clicking on an item will display the corresponding detailed logs.

You will see in these logs the events received by the server, the messages sent to the device...

Should you ever need to access the raw logs generated by the SDK, you can find them in `ruby_workspace/sdk_logs`.

## Keep your code clean ##

To keep your code well organized, it is recommanded that you put most of your code in a `modules` subfolder (and you can of course create subfolders in this subfolder...). You can define your own modules and classes to keep your code clean.

**in `my_agent/modules/my_module.rb`:**

``` ruby
module MyAwesomeModule

  def take_a_nap
    sleep 1
  end

end
```

**in `initial.rb`:**

``` ruby
require_relative 'modules/my_module'

module Initial_my_agent

  include MyAwesomeModule

  def new_msg_from_device(msg)
    SDK.API.log.debug("too tired to answer #{msg.content} right now")
    take_a_nap
    SDK.API.gate.reply(msg, "i'm fully rested now")
  end

end
```

## What's next? ##

### Agent guidelines ###

To be accepted, your agents must follow some rules described {file:guide/guidelines.md in the guidelines}. Notably, your agent must be **stateless**, so you must not use global variables other than the ones provided to you by the SDK (do not declare global variables, do not use class variables, ...).

### Using the API ###

The SDK provides you with an API with methods to help you sending messages to devices, writing logs, accessing configuration options, ... Check the related guide {file:guide/sdk_api.md here}.

### Automated testing ###

You can test your agent without using a device thanks to the test utilities of the SDK.

The SDK gives you tests helpers that should work with any testing framework. These helpers enables you to simulate sending messages to the server and verifying your agent send the appropriate response.

Additionally, we strongly encourages you to use the [Rspec](http://rubydoc.info/gems/rspec-core/file/README.md) testing framework. The web interface has a tab named ["Unit tests"](http://0.0.0.0:5000/unit_tests) where you can easily run your Rspec tests, see the results live, and saving them for future reference. Plus using Rspec will allow your tests to be run by Mobile Devices on the real development servers so we will be able to check if your agent works in a more realistic environment.

As an added bonus, the SDK testing framework also enables you to send a message to a device and check that your device answers correctly.

You can find more information on how to test your agents {file:guide/tests.md in this guide}.