#########################################################
# Xavier Demompion : xavier.demompion@mobile-devices.fr
# Mobile Devices 2013
#########################################################


# @api public
# This module defines the events an agent can receive, along a few utilities methods.
# This module does not have any agent-specific configuration.
module CloudConnectServices

  # @!group Events

  # An event received when a device is connected or disconnected.
  class Presence < Struct.new(:asset, :time, :bs, :type, :reason, :account, :meta)

    # @!attribute [rw] asset
    #   @return [String] the IMEI of the device or other similar unique identifier.

    # @!attribute [rw] time
    #   @return [Fixnum] a timestamp indicating when this event was received.

    # @!attribute [rw] bs
    #   @return [String] identifier of the source binary server (entry point of the MDI cloud).

    # @!attribute [rw] type
    #   @return [String] 'connect', 'reconnect' or 'disconnect'.

    # @!attribute [rw] reason
    #   @return [String] the reason for the event.

    # @!attribute [rw] meta
    #   @return [Hash] some meta data associated with the event (often empty).

    # @!attribute [rw] account
    #   @return [String] account name used.

    # Constructor.
    #
    # Hash representation of a presence:
    #
    #   ``` ruby
    #   {
    #   meta => self.meta,
    #   payload => {
    #     'asset' => self.asset,
    #     'time' => self.time,
    #     'bs' => self.bs,
    #     'type' => self.type,
    #     'reason' => self.reason,
    #     'account' => self.account
    #   }
    #   ```
    #
    def initialize(struct)
      self.meta = struct['meta']
      payload = struct['payload']
      self.asset = payload['asset']
      self.time = payload['time']
      self.bs = payload['bs']
      self.type = payload['type']
      self.reason = payload['reason']
      self.account = meta['account']

      if type != 'connect' && type != 'reconnect' && type != 'disconnect'
        raise "Wrong type of presence : #{type}"
      end
    end

    # Returns a hash representation of the event.
    # See the constructor documentation for the format.
    # @return a hash representation of the event.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['meta'] = self.meta
      r_hash['payload'] = {
        'asset' => self.asset,
        'time' => self.time,
        'bs' => self.bs,
        'type' => self.type,
        'reason' => self.reason,
        'account' => self.account
      }
      r_hash.delete_if { |k, v| v.nil? }
    end

  end

  # Holds data sent by the device to the server or data sent by the server to a device.
  class Message < Struct.new(:id, :parent_id, :thread_id, :asset, :sender, :recipient, :type, :recorded_at, :received_at, :channel,:account, :meta, :content)
    # @!attribute [rw] id
    #   The unique ID of the message. If the message comes from the device, this is a temporary ID set by the device.
    #   The server do not use those temporary IDs; instead, it will generate a new ID
    #   and will inform the device of this new ID in the ACK message.
    #   If the message is generated by the server, this ID is not temporary.
    #   @return [Fixnum] the unique ID of the message.

    # @!attribute [rw] asset
    #   @return [String] the IMEI (or similar unique identification number) of the device who
    #     either sent this message or to whom this message is destined.

    # @!attribute [rw] sender
    #   @return [String] the sender identifier; will often be the same as the asset if this message comes
    #     from a device, or `@@server` if the message comes from the server.

    # @!attribute [rw] recipient
    #   @return [String] Recipient identifier, often the same as the asset.

    # @!attribute [r] type
    #   @return [String] always "message".

    # @!attribute [rw] recorded_at
    #   @return [Fixnum] a timestamp indicating when this message was created.

    # @!attribute [rw] received_at
    #   @return [Fixnum] a timestamp indicating when this message was received.

    # @!attribute [rw] channel
    #   @return [String] the channel on which this message was received or will be emitted.

    # @!attribute [rw] payload
    #   @return [String] the content of the message.

    # @!attribute [rw] account
    #   @return [String] the account name used by the sender.

    # @!attribute [rw] meta
    #   @return [Hash] meta data associated with this message; often empty or `nil`.

    # @!attribute [rw] parent_id
    #   @return the ID of the parent message if this message is a response to another message.

    # @param [Hash] struct messages can be represented as a raw hash with the following format:
    #
    #   ``` ruby
    #   {
    #   'meta' => self.meta,
    #   'payload' => {
    #     'payload' => self.content,
    #     'channel' => self.channel,
    #     'parent_id' => self.parent_id,
    #     'thread_id' => self.thread_id,
    #     'id' => self.id,
    #     'asset' => self.asset,
    #     'sender' => self.sender,
    #     'recipient' => self.recipient,
    #     'type' => self.type,
    #     'recorded_at' =>  self.recorded_at,
    #     'received_at' =>  self.received_at,
    #     'channel' =>  self.channel
    #   }
    #   ```
    #
    # @api private
    def initialize(struct = nil)
      if struct.blank?
        self.meta = {}

        self.parent_id = nil
        self.thread_id = nil
        self.asset = nil
        self.sender = '@@server@@'
        self.recipient = nil
        self.type = 'message'
        self.recorded_at = 007
        self.received_at = 007

        #todo : marche pas tel quel
        if @CHANNEL && @CHANNEL[0]
          self.channel = @CHANNEL[0]
        else
          self.channel = nil
        end

        self.content = nil

      else

        self.meta = struct['meta']
        payload = struct['payload']

        self.content = payload['payload']
        self.id = payload['id']
        self.parent_id = payload['parent_id']
        self.thread_id = payload['thread_id']
        self.asset = payload['asset']
        self.sender = payload['sender']
        self.recipient = payload['recipient']
        self.type = payload['type']
        self.recorded_at = payload['recorded_at']
        self.received_at = struct['received_at']
        self.channel = payload['channel']

        if meta.is_a? Hash
          self.account = meta['account']
        end

        if self.type != 'message'
          raise "Message: wrong type of message : '#{type}'"
          return
        end

        if self.id.blank?
          self.id = CC.indigen_next_id
        end

      end
    end

    # Hash representation of a message.
    #
    #   ``` ruby
    #   {'meta' => self.meta,
    #   'payload' => {
    #     'payload' => self.content,
    #     'channel' => self.channel,
    #     'parent_id' => self.parent_id,
    #     'thread_id' => self.thread_id,
    #     'id' => self.id,
    #     'asset' => self.asset,
    #     'sender' => self.sender,
    #     'recipient' => self.recipient,
    #     'type' => self.type,
    #     'recorded_at' =>  self.recorded_at,
    #     'received_at' =>  self.received_at,
    #     'channel' =>  self.channel
    #   }
    #   ```
    #
    # @return [Hash] a hash representing this message.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['meta'] = self.meta
      r_hash['payload'] = {
        'payload' => self.content,
        'channel' => self.channel,
        'parent_id' => self.parent_id,
        'thread_id' => self.thread_id,
        'id' => self.id,
        'asset' => self.asset,
        'sender' => self.sender,
        'recipient' => self.recipient,
        'type' => self.type,
        'recorded_at' =>  self.recorded_at,
        'received_at' =>  self.received_at,
        'channel' =>  self.channel
      }
      r_hash.delete_if { |k, v| v.nil? }
    end

    # Pushes the message to the device without any preliminary setup.
    # Useful if you want to do all the setup yourself.
    # @api private
    def fast_push()
      CC.push(self.to_hash)
    end

    # Sends this message to the device, using the current message configuration.
    #
    # This method will set the `received_at` and `recorded_at` fields to `Time.now` and
    # encode the message with Protogen if necessary. Will also set the sender to `@@server@@`.
    #
    # If the method parameters are not defined the current values stored in the message will be used.
    #
    # @param [String] asset the IMEI of the device or other similar unique identifier.
    # @param [Account] account name to use.
    def push(asset = nil, account = nil)
        # set asset
        self.asset = asset if asset.nil?
        self.recipient = asset if asset.nil?

        # set sender if not defined (ie a direct push)
        self.sender ||= '@@server@@'

        # set acount is meta
        self.meta['account'] = account if account.nil?


        # set received_at and recorded_at
        self.received_at = Time.now
        self.recorded_at = Time.now
        CloudGate.message_sent(self)

        # Protogen encode
        if defined? ProtogenAPIs
          begin
            encoded = ProtogenAPIs.encode(self)

            if encoded.is_a? String
              self.content = encoded
              CC.logger.info("Protogen content is simple string")
            elsif encoded.is_a? Array
              CC.logger.info("Protogen content is an array of size #{encoded.size}")
              self.content = encoded[-1]
              # remove last fragment from list
              encoded.slice!(-1)
              # let create X fragment
              encoded.each { |content|
                frg = self.clone
                frg.id = CC.indigen_next_id
                frg.content = content
                frg.fast_push
              }
            else
              raise "message push protogen unknown encoded type : #{encoded.type}"
            end

          rescue Protogen::UnknownMessageType => e
            if $allow_non_protogen
              CC.logger.warn("CloudConnectServices:Messages.push: unknown protogen message type because #{e.inspect}")
            else
              raise e
            end
          end
        else
          if $allow_non_protogen
            CC.logger.warn('CloudConnectServices:Messages.push: ProtogenAPIs not defined')
          else
            raise "No Protogen defined"
          end
        end

        self.fast_push
    end

    # Reply to this message with the given content.
    # @param [String] content content to reply with.
    # @param [String] cookies Protogen cookies.
    def reply_content(content, cookies)
      msg = self.clone # todo : check si on clone bien récursivement les table de hash
      msg.parent_id = self.id
      msg.id = CC.indigen_next_id
      msg.content = content
      msg.meta['protogen_cookies'] = cookies
      msg.sender = self.recipient
      msg.push(self.asset, self.account)
    end

  end

  # Track data sent by a device.
  class Track < Struct.new(:id, :asset, :data, :account, :meta)
    # @!attribute [rw] id
    #   @return [Fixnum] the temporary message ID sent by the device.

    # @!attribute [rw] asset
    #   @return [String] the IMEI of the device who sent the message.

    # @!attribute [rw] meta
    #   @return [Hash] meta data associated with the track, generally empty or `nil`.

    # @!attribute [rw] data
    #   @return [Hash] a hash of track data with the following fields: latitude, longitude, recorded_at, received_at, field1, field2, ...

    # @!attribute [rw] account
    #   @return [String] the account name used.

    # Constructor.
    # The hash format of a track is:
    #
    #   ```ruby
    #     {
    #       'meta' => self.meta,
    #       'payload' => {
    #       'id' => self.id,
    #       'asset' => self.asset,
    #       'data' => self.data
    #     }
    #   ```
    #
    # @param [Hash] struct this hash must have the above format.
    def initialize(struct)

      self.meta = struct['meta']
      payload = struct['payload']

      self.id = payload['id']
      self.asset = payload['asset']
      self.data = payload['data']
      self.account = self.meta['account']

    end

    # @return [Hash] a hash representation of this event. See constructor documentation for the format.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['meta'] = self.meta
      r_hash['payload'] = {
        'id' => self.id,
        'asset' => self.asset,
        'data' => self.data
      }
      r_hash.delete_if { |k, v| v.nil? }
    end
  end

  # An event sent when a scheduled order is going to be executed.
  class Order < Struct.new(:agent, :code, :params)

    # @!attribute [rw] agent
    #   @return [String] the name of the agent which requested this order

    # @!attribute [rw] code
    #   @return [String] the order name

    # @!attribute [rw] params
    #   @return [Hash] parameters of the order

    # Constructor.
    #
    # Hash format of an order:
    #
    # ``` ruby
    # {
    # 'agent' => self.agent,
    # 'order' => self.order,
    # 'params' => self.params
    # }
    # ```
    #
    # @api private
    def initialize(struct)
      self.agent = struct['agent']
      self.code = struct['order']
      self.params = struct['params']

      #todo: test nullity or agent and order?

      if !(RH.running_agents.include?(self.agent))
        raise AgentNotFound , "Server: agent #{self.agent} is not running on this bay"
      end
    end

    # @return a hash representation of this order. See constructor documentation for format.
    # @api private
    def to_hash
      r_hash = {}
      r_hash['agent'] = self.agent
      r_hash['order'] = self.order
      r_hash['params'] = self.params
      r_hash.delete_if { |k, v| v.nil? }
    end
  end

  # @!endgroup

  # @api private
  class Log

    def initialize(header_txt)
      @head = header_txt
    end

    def debug(str_msg)
      CC.logger.debug("#{@head}#{str_msg}")
    end

    def info(str_msg)
      CC.logger.info("#{@head}#{str_msg}")
    end

    def warn(str_msg)
      CC.logger.warn("#{@head}#{str_msg}")
    end

    def error(str_msg)
      CC.logger.error("#{@head}#{str_msg}")
    end

  end

  # @api private
  class AgentNotFound < StandardError
  end



  #============================== METHODS ========================================

  # @api private
  def self.print_ruby_exception(e)
    stack=""
    e.backtrace.take(20).each { |trace|
      stack+="  >> #{trace}\n"
    }
    CC.logger.error("  RUBY EXCEPTION >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n >> #{e.inspect}\n\n#{stack}\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
  end


end


CCS = CloudConnectServices