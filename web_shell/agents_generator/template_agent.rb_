#!/usr/bin/env ruby
#########################################################
# Xavier Demompion : xavier.demompion@mobile-devices.fr
# Mobile Devices 2013
#########################################################

require 'yaml'

# Framework to be standalone
require 'active_support/all'
if (require_relative '../../local_cloud/fake_cloud_lib/cloud_connect_sdk_module')
  include CC
end

# User code
require_relative '../../../cloud_agents/XX_PROJECT_NAME/initial'

# XX_PROJECT_NAME agent
class Agent_XX_CLEAN_PROJECT_NAME

  # Protogen
  if File.exist?("#{generated_rb_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")
    require_relative 'protogen_XX_PROJECT_NAME/protogen_apis'
  end

  # Project
  @AGENT_NAME = ''
  @CHANNEL = ['com.mdi.services.XX_PROJECT_NAME']

  def initialize() # constructor
    log.info("root path is = \"#{root_path}\"")

    @AGENT_NAME = 'XX_PROJECT_NAME'

    # Load dynamic channel
    @CHANNEL = config['Dynamic_channel_str']

    if @CHANNEL.is_a? String
      @CHANNEL = ["#{@CHANNEL}"]
    end

    if (@CHANNEL == nil) || (@CHANNEL.length == 0)
      @CHANNEL = ['com.mdi.services.XX_PROJECT_NAME']
    end
    @has_protogen = File.exist?("#{generated_rb_path}/protogen_XX_PROJECT_NAME/protogen_apis.rb")


    log.info("init as protogen=#{@has_protogen} with dynamic channel = \"#{@CHANNEL}\"")
  end

  ######### Messages delivered for the agent ###########################
  def handle_presence(presence)
    PUNK.start('msgPresence')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][0] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgPresence','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- PRESENCE '#{presence.type}'")
    PUNK.start('handle')
    CC.logger.info("Server: handle_presence: pushing presence '#{presence.type}' of imei='#{presence.asset}' to agent 'XX_PROJECT_NAME'")
    new_presence_from_device(presence)
  end

  def handle_message(message)

    a_channel_is_valid = false
    @CHANNEL.each { |chan|
      if message.channel == chan
        a_channel_is_valid = true
      end
    }
    return unless a_channel_is_valid

    msg_type = ""
    PUNK.start('msgAgent')
    begin
      SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][1] += 1
      SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1

      # decode content as base64 (vm mode)
      message.content = Base64.decode64(message.content)

      is_protogen = false

      if @has_protogen
        begin
          # protogen decode
          msg, cookies = ProtogenAPIs.decode(message)
          message.content = msg
          message.meta['protogen_cookies'] = cookies
          msg_type = msg.class

          is_protogen = true
        rescue Protogen::UnknownMessageType => e
          # direct run
          CC.logger.warn("Server: handle_message: unknown protogen message type: #{e.inspect}")
          raise e unless $allow_non_protogen
        rescue MessagePack::UnpackError => e
          CC.logger.warn("Server: handle_message: MessagePack unpack error, either the payload is corrupted or not a protogen message : (err=#{e.inspect})")
          raise e unless $allow_non_protogen
        end
      else # not @has_protogen
        raise "No Protogen defined" unless $allow_non_protogen
      end

      PUNK.end('msgAgent','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- MSG[#{crop_ref(message.id,4)}] '#{msg_type}'")

    rescue Exception => e
      CCS.print_ruby_exeption(e)
      PUNK.end('msgAgent','ko','in',"AGENT:XX_PROJECT_NAMETNEGA <- MSG[#{crop_ref(message.id,4)}] '#{msg_type}'")
      return
    end


    # process
    PUNK.start('handle')
    if is_protogen

      CC.logger.info("Server: new protogen message of imei='#{message.asset}' to agent 'XX_PROJECT_NAME': #{message.content} ---------------------")
      ProtogenAPIs.process(self, message)
    else

      CC.logger.debug("Server: new standard message  of imei='#{message.asset}' to agent 'XX_PROJECT_NAME' ---------------------")
      new_msg_from_device(message)
    end

    message.id
  end

  def handle_track(track)
    PUNK.start('msgTrack')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][2] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgTrack','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- TRACK")

    PUNK.start('handle')
    CC.logger.info("Server: handle_track: pushing track of imei='#{track.asset}'' to agent 'XX_PROJECT_NAME' ---------------------")
    new_track_from_device(track)
  end

  def handle_order(order)
    #todo: test type, log on errors
    PUNK.start('msgOrder')
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['received'][3] += 1
    SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_received'] += 1
    PUNK.end('msgOrder','ok','in',"AGENT:XX_PROJECT_NAMETNEGA <- ORDER '#{order.code}'")

    PUNK.start('handle')
    CC.logger.info("Server: handle_order: pushing order #{order.code} to agent 'XX_PROJECT_NAME' ---------------------")
    new_order(order)
  end

  ########## Messages to devices #######################################

  class MessageGate

    def initialize(channel)
      @CHANNEL = channel
    end

    def push(asset, account, content)
      begin
        PUNK.start('push')
        msg = CCS::Message.new({
          'meta' => {},
          'payload' => {
            'type' => 'message',
            'sender' => '@@server@@',
            'channel' =>  @CHANNEL,
            'payload' => content
            }
          })

        msg.push(asset, account)
        # success !
        PUNK.end('push','ok','out',"SERVER -> MSG[#{crop_ref(msg.id,4)}]")



        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['push_sent_to_device'] += 1
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_sent'] += 1
      rescue Exception => e
        CC.logger.error("Error on push")
        CCS.print_ruby_exeption(e)
        PUNK.end('push','ko','out',"SERVER -> MSG")
        # stats:
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['err_on_push'] += 1
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_error'] += 1
      end
    end

    def reply(msg, content, cookies = nil)
      begin
        PUNK.start('reply')
        reply_id = msg.reply_content(content, cookies)
        # success !
        PUNK.end('reply','ok','out',"SERVER -> MSG[#{crop_ref(reply_id,4)}] [reply of #{crop_ref(msg.id,4)}]")
        # stats:
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['reply_sent_to_device'] += 1
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_sent'] += 1
      rescue Exception => e
        CC.logger.error("Error on reply")
        CCS.print_ruby_exeption(e)
        PUNK.end('reply','ko','out',"SERVER -> MSG (reply)")
        # stats:
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['err_on_reply'] += 1
        SDK_STATS.stats['agents']['XX_PROJECT_NAME']['total_error'] += 1
      end
    end
  end

  def gate
    @msgGate ||= begin
      MessageGate.new(@CHANNEL[0])
    end
  end


# keep commented code until RAgent developped

  # def send_message_to_device(account, asset, content)
  #   #todo add try catch
  #   begin
      # Message.new({
      #   asset:     asset,
      #   recipient: asset,
      #   sender:    '@@server@@',
      #   channel:   @CHANNEL[0],
      #   payload:   content.to_json
      #   }).push
  #   #note: for real wrapper : mock up account as bellow :
  #   #   account.messages.new({
  #   #     asset:     asset.imei,
  #   #     recipient: asset.imei,
  #   #     sender:    '@@server@@',
  #   #     channel:   @CHANNEL,
  #   #     payload:   content.to_json
  #   #     }, as: :agent).push

  ############### Logger ###############################################

  def log()
    @agent_logger ||= begin
      CCS::Log.new('Agent XX_PROJECT_NAME: ')
    end
  end

  ############### Redis ################################################
  def redis()
    @redis ||= Redis::Namespace.new('CCS:XX_PROJECT_NAME', :redis => CC.redis)
  end

  def redis_shared()
    @redis ||= Redis::Namespace.new("CCS:XX_PROJECT_NAME", :redis => CC.redis)
  end

  def redis_internal()
    @redis_internal ||= Redis::Namespace.new('CCSI:XX_PROJECT_NAME', :redis => CC.redis)
  end

  def redis_internal_shared()
    @redis_internal ||= Redis::Namespace.new("CCSI:XX_PROJECT_NAME", :redis => CC.redis)
  end

  ############### Config ###############################################
  #note: real wrapper wille have a .yml for each agent in a same folder
  def config()
    @config ||= begin
      if File.exist?("#{root_path}/config/XX_PROJECT_NAME.yml")
        @config = YAML::load(File.open("#{root_path}/config/XX_PROJECT_NAME.yml"))['development']
      elsif File.exist?("#{root_path}/config/XX_PROJECT_NAME.yml.example")
        @config = YAML::load(File.open("#{root_path}/config/XX_PROJECT_NAME.yml.example"))['development']
      else
        log.warn("NO CONFIG FILE FOUND in #{root_path}/config")
        @config = Hash.new
      end
    rescue Exception => e
      log.error("ERROR while loading configuration")
      CCS.print_ruby_exeption(e)
    end
  end

  ############### Path ################################################

  def root_path()
    'XX_PROJECT_ROOT_PATH'
  end

  ######################################################################

  include ProtogenAPIs if defined? ProtogenAPIs

  include Initial_agent_XX_PROJECT_NAME

end
